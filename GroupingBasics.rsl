scheme  GroupingBasics =
class
  type 
    Person = Text,
    Relation = (Person >< Person)-set,
    Group = Person-set,
    Grouping = Group-set
    
  value /* auxilliary functions */ 

    areFriends : Person >< Person >< Relation -> Bool
    areFriends(p1, p2, r) is ((p1,p2) isin r \/ (p2,p1) isin r),

    validGroup : Group >< Person-set -> Bool
    validGroup(h,ps) is
    let nh = h inter ps in
    (h = nh)
    end,

    checkPairs: Person >< Group >< Relation -> Bool
    checkPairs(person,group,relation) is
    if group = {}
      then true
    else
      let head = hd(group) in
      ~areFriends(person, head, relation) /\ checkPairs(person, group\{head}, relation)
      end
    end,

    groupNotFriends : Group >< Relation -> Bool
    groupNotFriends(h,r) is 
    if h = {}
      then true
    else
      let head = hd(h) in
      checkPairs(head, h\{head}, r) /\ groupNotFriends(h\{head},r)
      end
    end,

    isCorrectGrouping : Grouping >< Person-set >< Relation -> Bool
    isCorrectGrouping(gs,ps,r) is
    if gs = {} then true
    else
      let h = hd(gs), t = gs\{h} in
      validGroup(h,ps) /\ groupNotFriends(h,r) /\  isCorrectGrouping(t,ps,r)
      end
    end,

    isFriendsRelation : Relation -> Bool
    isFriendsRelation(r) is
    if (all (m, n) : Person >< Person :- (m,n) isin r => m ~= n)
      then true
    else
      false
    end,

    nonFriend : Person >< Person-set >< Relation -> Person
    nonFriend(p,ps,r) is 
    if (ps = {})
      then "NoPair"
    else
      let h = hd(ps) in
        if(~areFriends(p,h,r))
          then h
        else
        nonFriend(p,ps\{h},r)
        end
      end
    end,


    formPairs: Person-set >< Relation -> Grouping
    formPairs(ps,r) is
    if (card ps <= 1)
      then {}
    else
      let h = hd(ps), p = nonFriend(h,ps\{h},r) in
        if p = "NoPair"
          then formPairs(ps\{h},r)
        else
          {{h,p}} union formPairs(ps\{h,p},r)
        end
      end  
    end,


    addSingles: Grouping >< Person-set -> Grouping
    addSingles(gr,ps) is
    if ps = {}
     then gr
    else
      let p = hd(ps) in
        addSingles(gr union {{p}}, ps\{p})
      end
    end,


    newPS : Grouping >< Person-set -> Person-set
    newPS(gr, ps) is
    if(gr = {})
      then ps
    else
      let h = hd(gr) in
        (ps\h) inter newPS(gr\{h},ps)
      end
    end,


    validGroup: Person >< Group >< Relation -> Bool
    validGroup(p,g,r) is
    if g = {}
      then true
    else
      let h = hd(g) in
        if areFriends(p,h,r)
          then false
        else
          validGroup(p,g\{h},r)
        end
      end
    end,


    placeInGroup : Person >< Grouping >< Relation -> Group
    placeInGroup(p,gr,r) is
    if gr = {}
      then {}
    else
      let g = hd(gr) in
        if validGroup(p,g,r)
          then {p} union g
        else
          placeInGroup(p,gr\{g},r)
        end
      end
    end,


    finalGroup : Grouping >< Person-set >< Relation -> Grouping
    finalGroup(gr,ps,r) is
    if ps = {}
      then gr
    else
      let p = hd(ps), gm = placeInGroup(p,gr,r) in
        if gm = {}
          then finalGroup(gr,ps\{p},r)
        else
          finalGroup({gm} union(gr\{gm\{p}}),ps\{p},r)
        end
      end
    end


 end